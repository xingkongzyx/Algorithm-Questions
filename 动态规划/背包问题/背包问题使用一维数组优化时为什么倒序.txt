结合 474. 一和零 来谈

这题倒序来优化空间我想了很久终于明白了： 1.首先“记录本”不一样了，我本来应该拿三维数组记录的，比如dp[i][m][n]代表前i个字符串中满足m个0，n个1的最大子集数，这时候我们就顺着来，因为每一个层数我们都会记录，但是递推公式发现只和上一层有关，也就是dp[i][m][n]只和dp[i-1][][]这一层的有关，那么就可以进行优化。 2.我只用一个二维的“记录本”来记录上一层，也就是dp[m][n]代表的意义是上一层满足m个0和n个1的最大子集数，我没法找到任意一层了，因为我现在只有一个更小的“记录本”，所以我要保证算的过程中，永远能用上一层的数据，我就必须得倒着来，因为正着来的时候，
我算dp[m][n] = dp[m-zeros][n-ones]就错了, 因为本来要用上一次赋值了的dp[m-zeros][n-ones]结果，你在这一层遍历先赋值了他们，后来才算的dp[m][n]，乱了，上一层数据没了，给你盖住了！ 总之，倒序的目的就是只用一维数组，从而省下了空间，因为记录那么多层没必要，我只要上一层就ok。

https://leetcode.cn/problems/ones-and-zeroes/solution/dong-tai-gui-hua-zhuan-huan-wei-0-1-bei-bao-wen-ti/


01背包 一维数组
正序遍历用一个物品塞满背包，每次覆盖的数据都是同一个物品塞满的情况. 反向遍历就是每次只塞一个，并且比较的数据只来自上一轮，以及当前的value[i]

01背包滚动数组写法中，内层循环必须倒序遍历。因为在二维数组写法中，每行值的更新依赖于上一行的值；而一维写法中每个值的更新依赖于还没被更新的前面元素的值。

换个说法，一维写法中每个值的更新依赖于上次循环更新过且本次循环还未更新过的前面元素的值。

一维数组写法相当于二维数组写法每行数据拷贝给下一行用以下一行的数据更新。

为什么两个for循环不能调换
先遍历背包容量&倒序遍历相当于最大的容量只能装背包中物品的值的最大的一个，而不能够基于前面的基础进行累加，因为前面此时都是 0