/* 
* 1. 确定dp数组以及下标的含义
* dp[i]: 凑成目标正整数为i的排列个数为dp[i]. 排列的化(1,2)以及(2,1)算是不同的排列

* 2. 确定递推公式
* dp[i] += dp[i - nums[j]]

* 3. dp数组如何初始化
* dp[0] = 1  因为递推公式中有 "i-nums[j]" 说明后面的下标元素需要用到前面的下标元素。所以第一个值也就是 dp[0] 必须被初始化，还必须是1，否则 "+= dp[i - nums[j]]" 还会是 0.
 
* 4. 确定遍历顺序
* 如果把遍历 nums（物品）放在外循环，遍历 target 作为内循环的话，举一个例子：计算 dp[4] 的时候，结果集只有 {1,3} 这样的集合，不会有 {3,1} 这样的集合。
/ 原因是因为针对 "nums[0] = 1" 的遍历已经在最开始时结束，那个时候的 dp[4] 对应的排列结果是 {1,1,1,1}。
/ 然后针对 "nums[1] = 2"遍历，dp[4] 对应的排列结果是 {1,1,1,1}, {1,1,2}, {2,2}, 
/ 最后针对 nums[2] = 3 进行遍历. 此时 dp[4] += dp[4-3], 也就是在上面已有的排列上加入 {1,3}。
/ 而应有的 {3,1} 却永远不会出现，因为针对 nums[0] = 1 遍历的时候，dp[4]那个时候得到的只能是 dp[4] += dp[4-1]；而 dp[3] 那时因为只处于对 "nums[0] = 1" 进行遍历，dp[3]那时所持有的排列是 {1,1,1}，dp[4] 只是在它的基础上再加了个1，最后的结果是 {1,1,1,1}. 而 {3,1} 由于 dp[3] 那时没有考虑由{3}组成的情况，{3,1} 也无法出现

target（背包）放在外循环，将nums（物品）放在内循环，内循环从前到后遍历。
*/
var combinationSum4 = function (nums, target) {
    let dp = new Array(target + 1).fill(0);
    dp[0] = 1;
    for (let i = 1; i <= target; i++) {
        for (let j = 0; j < nums.length; j++) {
            if (i >= nums[j]) dp[i] += dp[i - nums[j]];
        }
    }
    return dp[target];
};
console.log(combinationSum4([1, 2, 3], 4));
