/* 

# 时间复杂度：代码中有一个 for 循环遍历数组，循环次数与 nums 数组长度（也就是 presum 数组长度减 1）成正比，所以时间复杂度是 O(N)，其中 n 是 nums 数组的长度。
# 空间复杂度：代码中定义了 presum 数组，其长度为 nums 数组长度加 1，所以额外占用的空间和输入数组长度是线性关系，空间复杂度是 O(N)。


以下是 minPresum 可以初始化为 0 而不是 -Infinity 的原因：

从逻辑起点角度来看
在算法开始执行时，还没有真正去计算和遍历数组元素得到实际的前缀和数值，此时我们要设定一个初始值来代表 “到当前元素之前的所有前缀和之中的最小值” 这个概念。因为此刻并没有任何有效的前缀和存在，所以将其初始化为 0 是合理的，相当于设定了一个起始的参照值，意味着在还没开始 “积累” 前缀和的最开始阶段，最小的前缀和就是 0。

结合计算过程来理解
在后续的循环中，第一次计算 presum[1] （也就是第一个元素对应的前缀和，实际就是 nums[0] 本身），并进行 ans = Math.max(ans, presum[1] - minPresum) 这一步操作时，如果 minPresum 初始化为 0，那么 presum[1] - minPresum 就是当前元素的值本身（也就是第一个元素 nums[0] 的值），这刚好符合我们去寻找以第一个元素结尾的子数组最大和的逻辑起点，因为最初的最大子数组和就是第一个元素自己，这样能正确地开启后续不断更新最大子数组和的过程。
而如果把 minPresum 初始化为 -Infinity，那么 presum[1] - (-Infinity) 就会得到 Infinity，这会导致第一次计算得到的所谓 “以当前元素结尾的子数组和” 这个值完全不符合实际情况，并且后续每次与 ans 比较更新时都会出现异常，因为后续所有的 presum[i] - (-Infinity) 都会是 Infinity，这使得整个求最大子数组和的计算逻辑被破坏，无法正确地去比较和更新出真正的最大子数组和。

*/

var maxSubArray = function (nums) {
    let presum = new Array(nums.length + 1).fill(0);
    // * minPresum 初始化为 0，正如咱们之前讨论的，它用于记录遍历到当前元素之前的所有前缀和之中的最小值。最开始将其初始化为 0 是合理的，因为在还没有开始遍历数组元素、计算真正的前缀和时，不存在比 0 更小的 “前面的前缀和” 情况，所以可以先设为 0 作为初始最小值。
    let minPresum = 0;
    let ans = -Infinity;
    for (let i = 1; i < presum.length; i++) {
        // * presum[i] = presum[i - 1] + nums[i - 1]; 这一行代码就是按照前缀和的定义来计算每一个位置的前缀和，将前一个位置的前缀和加上当前位置对应的数组元素值，得到新的前缀和存储在 presum 数组中。
        presum[i] = presum[i - 1] + nums[i - 1];
        // * 这里通过用当前的前缀和 presum[i] 减去之前记录的前缀和最小值 minPresum，得到以当前元素结尾的某个子数组的和，然后和已经记录的最大和 ans 进行比较，取较大值更新 ans。如果前面的元素都是正数，最初 minPresum 为 0，此时就是用当前的前缀和去尝试更新最大子数组和；如果前面已经出现了更小的前缀和，减去那个更小的前缀和就能得到当前可能的最大子数组和情况，然后更新 ans。
        ans = Math.max(ans, presum[i] - minPresum);
        // * 这行代码用于更新 minPresum，不断比较当前的前缀和 presum[i] 和之前记录的最小值 minPresum，如果当前前缀和更小，就更新 minPresum，保证它始终记录的是遍历到当前元素之前的前缀和的最小值。
        minPresum = Math.min(minPresum, presum[i]);
    }
    return ans;
};
