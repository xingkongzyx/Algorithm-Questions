这是前缀和思想的核心点：**“以当前节点为结尾的路径” = “当前节点的前缀和 - 某个祖先的前缀和”**。
 所以只需要祖先前缀，就能完全覆盖所有情况。我们逐步拆开：

------

## 1. 路径和的分解公式

假设：

- 从根到当前节点 `node` 的前缀和 = `curSum`（包含 `node.val`）。
- 从根到某个祖先 `p` 的前缀和 = `pre`。

那么从 **`p` 的下一个节点**到 `node` 的路径和是：

`sum(p→node)=curSum−pre`

所以，如果我们要找“以当前节点结尾，和为 target 的路径”，只需要在祖先们的前缀和里查有没有等于 `curSum - target` 的 `pre`。

------

## 2. 为什么只要祖先前缀就够了

因为 **“路径”定义为树中的一条自上而下的连续链**。

- 对于以 `node` 结尾的路径，起点必然在 `node` 的祖先链上。
- 不可能从“非祖先”的节点绕过来，因为树没有回边。
- 也不需要考虑“自己作为起点”，因为那种情况已经包含在公式里（当 `pre = curSum - target`，其中 `pre` 可以是根到父节点的前缀，甚至是 0，表示从根开始）。

因此，只需要祖先前缀，就能枚举所有可能的起点，从而覆盖所有以当前节点为终点的路径。

------

## 3. 如果把自己也放进 map 会怎样？

- 如果当前节点的 `curSum` 也提前放进 map，那么在计算时会把“自己 - 自己”算作一条路径。
- 特别是当 `target = 0` 时，这种“自己配自己”必然触发错误的多计数。
- 所以必须在 **统计完以后**，才把 `curSum` 放进 map，作为“祖先”供后代节点使用。

------

## 4. 举个具体例子

树结构：

```
   1
    \
     2
```

目标和 `target = 3`。

- 到达节点 `2` 时：
  - `curSum = 1 + 2 = 3`
  - map 里只有祖先前缀 `{0:1, 1:1}`
  - 查 `curSum - target = 0`，map 里有 `0:1`，说明存在一条路径 `[1,2]` 和为 3 ✅
  - 如果提前把 `curSum=3` 放进 map，那么查的时候会发现 `3` 也在 map 中，等于错误地算了一条“[2] 自己 - 自己 = 0”路径 ❌

------

## 结论

- 只用祖先前缀就足够，因为 **路径起点必然在祖先链上**。
- 提前放自己会导致“自己当祖先”，从而错误多计。
- 正确顺序是：**先统计（只用祖先前缀），再把当前前缀加入，最后递归子树，回溯时移除**。

------

要不要我帮你画一个“执行过程表格”（每到一个节点，map 内容、curSum 值、统计结果分别是什么），这样可以直观地看到为什么只需要祖先前缀就够？