关于遍历时，是先污染再治理，还是说只遍历有值的节点，其实取决于你的递归的终止条件。**以 104 题为例**

**常见写法（需要 `if (node === null) return;`）**
像这种写法里：

```js
function DFS(node) {
    if (node === null) return;  // 必须拦住空节点

    curDepth += 1;
    maxDepth = Math.max(curDepth, maxDepth);
    
    DFS(node.left);
    DFS(node.right);
    
    curDepth -= 1;
}
```
为什么要判断空？ 因为递归时无条件调用 `DFS(node.left)`，必须拦住 null
因为这里的逻辑是：只要有节点，就要进入并更新深度。
如果不拦住空指针，递归下去就会报错（访问 `node.left` 时 node 是 null）。



**第二个版本（不需要判断 null）**


```js
function DFS(node, curDepth) {
    maxDepth = Math.max(maxDepth, curDepth);

    if (node.left) {
        DFS(node.left, curDepth + 1);
    }
    if (node.right) {
        DFS(node.right, curDepth + 1);
    }
}
```
这里为什么不需要 `if (node === null) return;`？
因为你**已经在进入子节点前做了判断**：

- `if (node.left)` 只有在左孩子存在时才递归
- `if (node.right)` 只有在右孩子存在时才递归

所以空节点根本不会被递归调用到 `DFS`，也就不需要在函数入口写一个 `if (node === null)` 来兜底。

我们就用一个小树来对比执行过程，看看为什么第一种写法会真的传 `null`，而第二种不会。

------

**🌳 例子二叉树**

```
    A
   /
  B
```

最大深度应该是 2。

------

**🔹 第一种写法（会传 `null`）**

```js
function DFS(node) {
    if (node === null) return;

    curDepth += 1;
    maxDepth = Math.max(curDepth, maxDepth);

    DFS(node.left);   // ⚠️ 无条件调用
    DFS(node.right);  // ⚠️ 无条件调用

    curDepth -= 1;
}
```

执行过程：

1. 进入 A → `curDepth=1`
   - `DFS(A.left)` 被调用，参数是 **B**
   - `DFS(A.right)` 被调用，参数是 **null**（因为 A 没有右孩子）
2. 进入 B → `curDepth=2`
   - `DFS(B.left)` 被调用，参数是 **null**
   - `DFS(B.right)` 被调用，参数是 **null**
3. 你看到没？这里的递归调用里确实会传 `null` 进去。
    所以必须在函数开头写 `if (node === null) return;` 来兜底，否则访问 `node.left` 就会报错。

------

**🔹 第二种写法（不会传 `null`）**

```js
function DFS(node, curDepth) {
    maxDepth = Math.max(maxDepth, curDepth);

    if (node.left) {
        DFS(node.left, curDepth + 1);  // 只有 node.left 存在才会递归
    }
    if (node.right) {
        DFS(node.right, curDepth + 1); // 同理
    }
}
```

执行过程：

1. 进入 A → `curDepth=1`
   - 检查 `node.left` → 是 B，不是 null，于是调用 `DFS(B, 2)`
   - 检查 `node.right` → 是 null，不递归
2. 进入 B → `curDepth=2`
   - 检查 `node.left` → null，不递归
   - 检查 `node.right` → null，不递归
3. 整个过程里，**从来没有把 null 传给 DFS**。

------

**✅ 对比结论**

- **第一种写法**：因为无条件调用 `DFS(node.left/right)`，所以 null 节点会传进来 → 必须在入口判断。
- **第二种写法**：提前检查孩子是否存在，null 根本不会传进去 → 入口可以省略判断。

