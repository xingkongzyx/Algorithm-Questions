/*
! 如果用end排序, 那么一个最大的好处就是区间列表里第一项的 end 是最小的 end, 这样就不用像上文提到的那样去找最小 end 了。在 end 排序下, 只有一种情况需要多加箭, 那就是next_start > cur_end时, 其他情况统统都是一支箭搞定, 这样从代码上还是思路上都简化了不少。
? https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/solution/tan-xin-an-endpai-xu-bi-an-startpai-xu-yao-hao-by-/
* 当我们保证直径结束点（每个元素对的第二个点）按照升序排列时, 我们就保证了箭尽量射当前气球的右边缘时, 不至于错过后续气球的右边缘, 因为它之后的气球的右边缘肯定大于它的右边缘。这时只要考虑他后面的气球的左边缘即是否小于当前右边缘即可确定气球是否有交叠。

?          Λ  
?    [-----|]     
?  [-------|---]  
?    [-----|---]
?       [--|---]
?          |  [-----]  // 只有此时需要再来一根


 * 用区间的尾部排序貌似效率会更好, 因为已经保证后面的区间右侧的值都是大于当前区间右侧的值, 所以将发射点设置在右侧边界, 后面的区间只有左边界比它更靠左,则可以被一起处理掉。
 * 这里换个example: [[10,16],[2,5],[1,6],[7,12]] 为例子:
 *
 * 1. 先排序, 按区间结束位置排序, 排序后: [[2,5], [1,6], [7,12], [10,16]]
 * 2. 遍历计算交叉区间,
 *   1) 发射点初始化为pos = 5, 需要的箭数量 arrows = 1;
 *   2) 区间[1, 6], 1 是小于5的, 在点 5 射箭可以干掉这个区间
 *   3) 区间[7, 12], 在 5 的位置射箭无法打掉, 说明需要增加一个新的发射点, 新的待发射点 pos = 12
 *   4) 区间[10,16], 10 < 12那么在 12 位置射箭可以干掉它
 *   5) 返回需要射击点数量
 *
 */
var findMinArrowShots = function (points) {
    //# 按照每个气球的右边界排序
    points.sort((pointA, pointB) => pointA[1] - pointB[1]);

    let arrows = 1;

    //# 获取排序后第一个气球右边界的位置, 我们可以认为是箭射入的位置
    let arrowPosition = points[0][1];

    for (let i = 1; i < points.length; i++) {
        //# 如果箭射入的位置小于下标为i这个气球的左边位置, 说明这支箭不能
        //# 击爆下标为i的这个气球, 需要再拿出一支箭, 并且要更新这支箭射入的
        //# 位置
        if (points[i][0] > arrowPosition) {
            arrows++;
            arrowPosition = points[i][1];
        }
    }

    return arrows;
};
