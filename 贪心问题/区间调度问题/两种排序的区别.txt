区间的左端升序和右端升序，其实是"对称"的，哪种方法都可行。只是做出来的思考的步骤有差异。选择简单的即可。

按左端升序也可以，计算箭数判断条件一样，不过每次要更新右边界的最小值right = min(right,points[i][1]);

按右端升序也其实就是省略了维护right的min这一步；

> 他们的贪心思想是一致的，尽可能多的有不重叠的区间, 所以取第二个数小的区间, 这样后边才有位置放其他的区间。
按右边排序的优势是不用一直维护 prevEnd, 因为当本轮访问的区间的第一个数小于等于 prevEnd 的时候(区间重叠)，其第二个数一定大于 prevEnd, 因为是根据右边排序的结果，只有当本轮访问的区间的第一个数大于 prevEnd 的时候(区间不重叠)才需要更新 prevEnd 到新的区间。
按左边排序则要一直维护 prevEnd, 因为两个区间有重叠的时候无法判断哪个区间的尾元素更靠近前面，需要用 min 进行计算。没重叠的时候也需要即时更新 prevEnd.